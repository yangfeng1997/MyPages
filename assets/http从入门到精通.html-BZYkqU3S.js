import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,b as i,o as a}from"./app-DIj9INsK.js";const t={};function p(l,s){return a(),n("div",null,s[0]||(s[0]=[i(`<h2 id="动态字符串类型" tabindex="-1"><a class="header-anchor" href="#动态字符串类型"><span>动态字符串类型</span></a></h2><h3 id="动态字符串类型-1" tabindex="-1"><a class="header-anchor" href="#动态字符串类型-1"><span>动态字符串类型</span></a></h3><h4 id="动态字符串类型-2" tabindex="-1"><a class="header-anchor" href="#动态字符串类型-2"><span>动态字符串类型</span></a></h4><h5 id="动态字符串类型-3" tabindex="-1"><a class="header-anchor" href="#动态字符串类型-3"><span>动态字符串类型</span></a></h5><h6 id="动态字符串类型-4" tabindex="-1"><a class="header-anchor" href="#动态字符串类型-4"><span>动态字符串类型</span></a></h6><p>####### 动态字符串类型</p><p>redis 使用了一种 SDS（simple dynamic string）类型的动态字符串，作为默认字符串的表示，并没有直接使用 C 语言中的字符串。</p><p>并且字符串的的<strong>键和值</strong>对在底层都是由 SDS 实现，因为键值对的键是一个字符串对象，字符串的值也是一个对象。</p><p>如果 list 中存储的也是字符串，那么列表中的每个字符串也都是 SDS 结构。</p><p>除了用来保存字符串值之外， SDS 还被用作缓冲区（buffer）： AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现。</p><p>SDS 结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>struct sdshdr {</span></span>
<span class="line"><span>    int len;       // 记录 buf 数组中已使用字节的数量，等于 SDS 所保存字符串的长度</span></span>
<span class="line"><span>    int free;      // 记录 buf 数组中未使用字节的数量</span></span>
<span class="line"><span>    char buf[];    // 字节数组，用于保存字符串</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p><p>![image-20250110184419641](Redis 设计与实现.assets/image-20250110184419641.png)</p><p>注意：保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 等操作都是由 SDS 函数自动完成，对使用者透明。这样做的好处是，可以重用一部分 C 语言字符串的函数，比如：有一个 SDS 的指针 s，可以直接使用 printf 函数，而不用专门编写 SDS 专门的打印函数。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>printf(&quot;%s&quot;, s-&gt;buf);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>SDS 对比 C 字符串的优点：</p><ol><li><p>C 字符串不记录自身长度，获取长度的复杂度为 O(n)。而 SDS 直接取 len 的值，复杂度为 O(1)。</p></li><li><p>C 字符串容易造成缓冲区溢出，比如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>char *strcat(char *dest, const char *src);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行 strcat 时，需要用户已经为 dest 分配了足够的内存，如果没有的话将会发生内存溢出。</p><p>但是 SDS 完全杜绝了这种可能性，因为 SDS API 会检查空间是否满足修改所需的要求，如果不满足，API 会自动将空间扩容，比如 SDS 中的 sdscat 函数。</p></li><li><p>SDS 可以减少内存的分配次数。因为 C 字符串总是保证 N+1 个字符长的数组，每次增长或缩短字符串都要进行内存重新分配，这其中设计内存分配，可能会涉及系统调用，比较耗时，况且 redis 中一般字符串的操作比较频繁。</p><p>SDS 通过空间预分配和惰性空间释放，也就是 buf 数组的长度不一定就是字符串长度 +1，数组里可以有未使用的字节，有 free 属性记录。</p><p><strong>空间预分配</strong>：</p><p>SDS api 当对一个 SDS 进行修改及扩容时，不仅会分配必须要的空间，还会分配额外未使用的空间，再下次字符串增长时，如果未使用的空间足够就会直接使用这个空间，不执行内存分配。</p><p>当修改时 len 属性长度小于 1MB 时，程序会多分配 len 属性大小的未使用空间，这时候 len == free，总空间为 len + free + 1byte。</p><p>当修改时 len 长度大于等于 1MB 时，程序会多分配 1MB 的未使用空间，这时候总空间为 len + 1MB + 1byte。</p><p><strong>惰性释放空间</strong>：</p><p>用于字符串的缩短操作，SDS 的 api 并不立即使用内存重分配来回收缩短后多出来的字节，而是保留了空间，并使用 free 属性将这些字节记录下来，等待再进行增长操作时方便使用。同时 SDS 也提供了 api 让我们可以在有需要时，真正释放 SDS 中的未使用的空间，不用担心惰性空间释放造成的内存浪费。</p></li><li><p>SDS 是二进制安全的，C 字符串中不能包含空字符，否则会提前被判为字符串结束，所以 C 只能保存文本数据，不适合保存二进制。</p><p>所有的 SDS api 都以处理二进制的方式处理 SDS 存放在 buf 数组里的数据，不会对空字符进行过滤或者限制，SDS 是二进制安全的。SDS 的 buf 属性不是保存字符的，而是保存二进制数据的。</p></li></ol><h2 id="链表" tabindex="-1"><a class="header-anchor" href="#链表"><span>链表</span></a></h2><p>链表提供高效的节点重排能力，和顺序性节点的访问方式，可以高效的增删节点，Redis 也构建了自己的链表。</p><p>Redis 中，当一个列表键包含了数量比较多的元素时，或者列表中包含的元素都是比较长的字符串时，Redis 就是使用链表作为列表键的底层实现。还有发布与订阅、慢查询、监视器等功能也用到链表。</p><p>链表结构定义如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct listNode {</span></span>
<span class="line"><span>    struct listNode *prev;   // 前置节点</span></span>
<span class="line"><span>    struct listNode *next;   // 后置节点</span></span>
<span class="line"><span>    void *value;             // 节点的值</span></span>
<span class="line"><span>} listNode;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>typedef struct list {</span></span>
<span class="line"><span>    listNode *head;          			// 表头节点</span></span>
<span class="line"><span>    listNode *tail;          			// 表尾节点</span></span>
<span class="line"><span>    unsigned long len;       			// 链表所包含的节点数量</span></span>
<span class="line"><span>    void *(*dup)(void *ptr); 			// 节点值复制函数</span></span>
<span class="line"><span>    void (*free)(void *ptr);            // 节点值释放函数</span></span>
<span class="line"><span>    int (*match)(void *ptr, void *key); // 节点值对比函数</span></span>
<span class="line"><span>} list;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![image-20250111003218735](Redis 设计与实现.assets/image-20250111003218735.png)</p><p>![image-20250111003311059](Redis 设计与实现.assets/image-20250111003311059.png)</p><p>redis 链表有如下特征：</p><ol><li>双向，获取某个节点的前置和后置节点都是 O(1)。</li><li>无环，表头节点 pre 和表尾节点 next 都指向 NULL，对链表的访问以 NULL 为终点。</li><li>带表头指针和表尾指针，通过成员 head 指针和 tail 指针，获得头尾节点复杂度为 O(1)。</li><li>带暗恋长的长度计数器，通过成员 len 记录链表节点数量，复杂度 O(1)。</li><li>多态：节点使用 void*指针来保存节点值，可以通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数，链表可以保存各种不同的类型值。</li></ol><h2 id="字典" tabindex="-1"><a class="header-anchor" href="#字典"><span>字典</span></a></h2>`,28)]))}const c=e(t,[["render",p]]),h=JSON.parse('{"path":"/%E6%95%99%E7%A8%8B/HTTP/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html","title":"HTTP从入门到精通","lang":"zh-CN","frontmatter":{"title":"HTTP从入门到精通","category":["HTTP"],"tag":["HTTP"],"description":"动态字符串类型 动态字符串类型 动态字符串类型 动态字符串类型 动态字符串类型 ####### 动态字符串类型 redis 使用了一种 SDS（simple dynamic string）类型的动态字符串，作为默认字符串的表示，并没有直接使用 C 语言中的字符串。 并且字符串的的键和值对在底层都是由 SDS 实现，因为键值对的键是一个字符串对象，字符串...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HTTP从入门到精通\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-25T17:53:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"烛风\\",\\"url\\":\\"https://yangfeng1997.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html"}],["meta",{"property":"og:site_name","content":"ZOFUN"}],["meta",{"property":"og:title","content":"HTTP从入门到精通"}],["meta",{"property":"og:description","content":"动态字符串类型 动态字符串类型 动态字符串类型 动态字符串类型 动态字符串类型 ####### 动态字符串类型 redis 使用了一种 SDS（simple dynamic string）类型的动态字符串，作为默认字符串的表示，并没有直接使用 C 语言中的字符串。 并且字符串的的键和值对在底层都是由 SDS 实现，因为键值对的键是一个字符串对象，字符串..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-25T17:53:14.000Z"}],["meta",{"property":"article:tag","content":"HTTP"}],["meta",{"property":"article:modified_time","content":"2025-04-25T17:53:14.000Z"}]]},"git":{"createdTime":1745603594000,"updatedTime":1745603594000,"contributors":[{"name":"137782866","username":"137782866","email":"137782866@qq.com","commits":1,"url":"https://github.com/137782866"}]},"readingTime":{"minutes":5.19,"words":1557},"filePathRelative":"教程/HTTP/http从入门到精通.md","excerpt":"<h2>动态字符串类型</h2>\\n<h3>动态字符串类型</h3>\\n<h4>动态字符串类型</h4>\\n<h5>动态字符串类型</h5>\\n<h6>动态字符串类型</h6>\\n<p>####### 动态字符串类型</p>\\n<p>redis 使用了一种 SDS（simple dynamic string）类型的动态字符串，作为默认字符串的表示，并没有直接使用 C 语言中的字符串。</p>\\n<p>并且字符串的的<strong>键和值</strong>对在底层都是由 SDS 实现，因为键值对的键是一个字符串对象，字符串的值也是一个对象。</p>\\n<p>如果 list 中存储的也是字符串，那么列表中的每个字符串也都是 SDS 结构。</p>","autoDesc":true}');export{c as comp,h as data};
