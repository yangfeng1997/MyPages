import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,b as r,o as a}from"./app-DIj9INsK.js";const p={};function s(n,t){return a(),e("div",null,t[0]||(t[0]=[r('<h2 id="为什么需要分布式共识算法" tabindex="-1"><a class="header-anchor" href="#为什么需要分布式共识算法"><span>为什么需要分布式共识算法？</span></a></h2><p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p><p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p><p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p><h2 id="主要分布式共识算法" tabindex="-1"><a class="header-anchor" href="#主要分布式共识算法"><span>主要分布式共识算法</span></a></h2><ol><li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li><li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li><li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li></ol><h2 id="paxos发展历史" tabindex="-1"><a class="header-anchor" href="#paxos发展历史"><span>Paxos发展历史</span></a></h2><p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p><p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p><p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p><p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p><p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p><h2 id="basic-paxos算法流程" tabindex="-1"><a class="header-anchor" href="#basic-paxos算法流程"><span>Basic Paxos算法流程</span></a></h2><p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p><ul><li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li><li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li><li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li></ul><p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p><p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p><p>Paxos解决竞争分2个阶段：</p><ol><li><p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p><p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p><p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p></li><li><p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p></li></ol><ul><li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li><li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li></ul><p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p><p><strong>Multi Paxos共识算法</strong></p><p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p><p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p><ul><li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li><li>得到决策节点多数派的批准时，竞选主节点成功。</li></ul><p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p><p><strong>只有主从节点</strong></p><p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p><p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p><ul><li>如何选主</li><li>如何把数据复制到各个节点上</li><li>怎么保证过程是安全的</li></ul><p>3个问题解决了，就达成共识了。</p><p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p><p><strong>问题2：数据复制的过程？</strong></p><ul><li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li><li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li><li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li><li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li></ul><p><strong>问题3：过程是安全的？</strong></p><ul><li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li><li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li></ul><p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p><p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>',38)]))}const c=o(p,[["render",s]]),g=JSON.parse('{"path":"/%E6%95%99%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1%20copy.html","title":"计算机网络3","lang":"zh-CN","frontmatter":{"title":"计算机网络3","category":["计算机网络"],"tag":["计算机网络"],"description":"为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"计算机网络3\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-25T17:53:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"烛风\\",\\"url\\":\\"https://yangfeng1997.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1%20copy.html"}],["meta",{"property":"og:site_name","content":"ZOFUN"}],["meta",{"property":"og:title","content":"计算机网络3"}],["meta",{"property":"og:description","content":"为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-25T17:53:14.000Z"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:modified_time","content":"2025-04-25T17:53:14.000Z"}]]},"git":{"createdTime":1745603594000,"updatedTime":1745603594000,"contributors":[{"name":"137782866","username":"137782866","email":"137782866@qq.com","commits":1,"url":"https://github.com/137782866"}]},"readingTime":{"minutes":6,"words":1799},"filePathRelative":"教程/计算机网络/计算机网络1 copy.md","excerpt":"<h2>为什么需要分布式共识算法？</h2>\\n<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>\\n<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>\\n<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>","autoDesc":true}');export{c as comp,g as data};
