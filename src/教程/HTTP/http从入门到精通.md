---
title: HTTP从入门到精通
category:
  - HTTP
tag:
  - HTTP
---

## 动态字符串类型

### 动态字符串类型

#### 动态字符串类型

##### 动态字符串类型

###### 动态字符串类型

####### 动态字符串类型

redis 使用了一种 SDS（simple dynamic string）类型的动态字符串，作为默认字符串的表示，并没有直接使用 C 语言中的字符串。

并且字符串的的**键和值**对在底层都是由 SDS 实现，因为键值对的键是一个字符串对象，字符串的值也是一个对象。

如果 list 中存储的也是字符串，那么列表中的每个字符串也都是 SDS 结构。

除了用来保存字符串值之外， SDS 还被用作缓冲区（buffer）： AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现。

SDS 结构：

```
struct sdshdr {
    int len;       // 记录 buf 数组中已使用字节的数量，等于 SDS 所保存字符串的长度
    int free;      // 记录 buf 数组中未使用字节的数量
    char buf[];    // 字节数组，用于保存字符串
};
```

说明：

![image-20250110184419641](Redis 设计与实现.assets/image-20250110184419641.png)

注意：保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 等操作都是由 SDS 函数自动完成，对使用者透明。这样做的好处是，可以重用一部分 C 语言字符串的函数，比如：有一个 SDS 的指针 s，可以直接使用 printf 函数，而不用专门编写 SDS 专门的打印函数。

```
printf("%s", s->buf);
```

SDS 对比 C 字符串的优点：

1. C 字符串不记录自身长度，获取长度的复杂度为 O(n)。而 SDS 直接取 len 的值，复杂度为 O(1)。

2. C 字符串容易造成缓冲区溢出，比如：

    ```
    char *strcat(char *dest, const char *src);
    ```

    执行 strcat 时，需要用户已经为 dest 分配了足够的内存，如果没有的话将会发生内存溢出。

    但是 SDS 完全杜绝了这种可能性，因为 SDS API 会检查空间是否满足修改所需的要求，如果不满足，API 会自动将空间扩容，比如 SDS 中的 sdscat 函数。

3. SDS 可以减少内存的分配次数。因为 C 字符串总是保证 N+1 个字符长的数组，每次增长或缩短字符串都要进行内存重新分配，这其中设计内存分配，可能会涉及系统调用，比较耗时，况且 redis 中一般字符串的操作比较频繁。

    SDS 通过空间预分配和惰性空间释放，也就是 buf 数组的长度不一定就是字符串长度 +1，数组里可以有未使用的字节，有 free 属性记录。

    **空间预分配**：

    SDS api 当对一个 SDS 进行修改及扩容时，不仅会分配必须要的空间，还会分配额外未使用的空间，再下次字符串增长时，如果未使用的空间足够就会直接使用这个空间，不执行内存分配。

    当修改时 len 属性长度小于 1MB 时，程序会多分配 len 属性大小的未使用空间，这时候 len == free，总空间为 len + free + 1byte。

    当修改时 len 长度大于等于 1MB 时，程序会多分配 1MB 的未使用空间，这时候总空间为 len + 1MB + 1byte。

    **惰性释放空间**：

    用于字符串的缩短操作，SDS 的 api 并不立即使用内存重分配来回收缩短后多出来的字节，而是保留了空间，并使用 free 属性将这些字节记录下来，等待再进行增长操作时方便使用。同时 SDS 也提供了 api 让我们可以在有需要时，真正释放 SDS 中的未使用的空间，不用担心惰性空间释放造成的内存浪费。

4. SDS 是二进制安全的，C 字符串中不能包含空字符，否则会提前被判为字符串结束，所以 C 只能保存文本数据，不适合保存二进制。

    所有的 SDS api 都以处理二进制的方式处理 SDS 存放在 buf 数组里的数据，不会对空字符进行过滤或者限制，SDS 是二进制安全的。SDS 的 buf 属性不是保存字符的，而是保存二进制数据的。

## 链表

链表提供高效的节点重排能力，和顺序性节点的访问方式，可以高效的增删节点，Redis 也构建了自己的链表。

Redis 中，当一个列表键包含了数量比较多的元素时，或者列表中包含的元素都是比较长的字符串时，Redis 就是使用链表作为列表键的底层实现。还有发布与订阅、慢查询、监视器等功能也用到链表。

链表结构定义如下：

```
typedef struct listNode {
    struct listNode *prev;   // 前置节点
    struct listNode *next;   // 后置节点
    void *value;             // 节点的值
} listNode;

typedef struct list {
    listNode *head;          			// 表头节点
    listNode *tail;          			// 表尾节点
    unsigned long len;       			// 链表所包含的节点数量
    void *(*dup)(void *ptr); 			// 节点值复制函数
    void (*free)(void *ptr);            // 节点值释放函数
    int (*match)(void *ptr, void *key); // 节点值对比函数
} list;
```

![image-20250111003218735](Redis 设计与实现.assets/image-20250111003218735.png)

![image-20250111003311059](Redis 设计与实现.assets/image-20250111003311059.png)

redis 链表有如下特征：

1. 双向，获取某个节点的前置和后置节点都是 O(1)。
2. 无环，表头节点 pre 和表尾节点 next 都指向 NULL，对链表的访问以 NULL 为终点。
3. 带表头指针和表尾指针，通过成员 head 指针和 tail 指针，获得头尾节点复杂度为 O(1)。
4. 带暗恋长的长度计数器，通过成员 len 记录链表节点数量，复杂度 O(1)。
5. 多态：节点使用 void*指针来保存节点值，可以通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数，链表可以保存各种不同的类型值。

## 字典










































































