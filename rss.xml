<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://yangfeng1997.github.io/MyPages/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://yangfeng1997.github.io/MyPages/rss.xml" rel="self" type="application/rss+xml"/>
    <title>ZOFUN</title>
    <link>https://yangfeng1997.github.io/MyPages/</link>
    <description>烛风的个人博客</description>
    <language>zh-CN</language>
    <pubDate>Mon, 28 Apr 2025 16:32:47 GMT</pubDate>
    <lastBuildDate>Mon, 28 Apr 2025 16:32:47 GMT</lastBuildDate>
    <generator>@vuepress/plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>分布式</category>
    <category>使用指南</category>
    <category>指南</category>
    <category>樱桃</category>
    <category>火龙果</category>
    <category>水果</category>
    <category>草莓</category>
    <category>蔬菜</category>
    <category>建站</category>
    <category>VuePress</category>
    <category>开源代码</category>
    <category>苹果</category>
    <category>香蕉</category>
    <category>HTTP</category>
    <category>计算机网络</category>
    <item>
      <title>分布式共识算法基础</title>
      <link>https://yangfeng1997.github.io/MyPages/datastruct/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/datastruct/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">分布式共识算法基础</source>
      <description>为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...</description>
      <category>分布式</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>为什么需要分布式共识算法？</h2>
<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>
<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>
<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>
<h2>主要分布式共识算法</h2>
<ol>
<li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li>
<li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li>
<li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li>
</ol>
<h2>Paxos发展历史</h2>
<p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p>
<p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p>
<p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p>
<p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p>
<p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p>
<h2>Basic Paxos算法流程</h2>
<p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p>
<ul>
<li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li>
<li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li>
<li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ul>
<p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p>
<p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p>
<p>Paxos解决竞争分2个阶段：</p>
<ol>
<li>
<p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p>
<p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p>
<p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p>
</li>
<li>
<p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p>
</li>
</ol>
<ul>
<li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li>
<li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li>
</ul>
<p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p>
<p><strong>Multi Paxos共识算法</strong></p>
<p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p>
<p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p>
<ul>
<li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li>
<li>得到决策节点多数派的批准时，竞选主节点成功。</li>
</ul>
<p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p>
<p><strong>只有主从节点</strong></p>
<p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p>
<p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p>
<ul>
<li>如何选主</li>
<li>如何把数据复制到各个节点上</li>
<li>怎么保证过程是安全的</li>
</ul>
<p>3个问题解决了，就达成共识了。</p>
<p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p>
<p><strong>问题2：数据复制的过程？</strong></p>
<ul>
<li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li>
<li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li>
<li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li>
<li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li>
</ul>
<p><strong>问题3：过程是安全的？</strong></p>
<ul>
<li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li>
<li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li>
</ul>
<p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p>
<p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>
]]></content:encoded>
    </item>
    <item>
      <title>主要功能与配置演示</title>
      <link>https://yangfeng1997.github.io/MyPages/demo/</link>
      <guid>https://yangfeng1997.github.io/MyPages/demo/</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">主要功能与配置演示</source>
      <category>使用指南</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
    </item>
    <item>
      <title>布局与功能禁用</title>
      <link>https://yangfeng1997.github.io/MyPages/demo/disable.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/demo/disable.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">布局与功能禁用</source>
      <description>你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。</description>
      <category>使用指南</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<p>你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。</p>
<!-- more -->
<p>本页面就是一个示例，禁用了如下功能:</p>
<ul>
<li>导航栏</li>
<li>侧边栏</li>
<li>路径导航</li>
<li>页面信息</li>
<li>贡献者</li>
<li>编辑此页链接</li>
<li>更新时间</li>
<li>上一篇/下一篇 链接</li>
<li>评论</li>
<li>页脚</li>
<li>返回顶部按钮</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>布局</title>
      <link>https://yangfeng1997.github.io/MyPages/demo/layout.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/demo/layout.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">布局</source>
      <description>布局包括: 导航栏 侧边栏 页脚 同时每个页面包含: 路径导航 标题和页面信息 TOC (文章标题列表) 贡献者、更新时间等页面元信息 评论 主题也带有以下元素: 夜间模式按钮 返回顶部按钮 打印按钮 你可以在主题选项和页面的 frontmatter 中自定义它们。</description>
      <category>指南</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<p>布局包括:</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/layout/navbar.html" target="_blank" rel="noopener noreferrer">导航栏</a></li>
<li><a href="https://theme-hope.vuejs.press/zh/guide/layout/sidebar.html" target="_blank" rel="noopener noreferrer">侧边栏</a></li>
<li><a href="https://theme-hope.vuejs.press/zh/guide/layout/footer.html" target="_blank" rel="noopener noreferrer">页脚</a></li>
</ul>
<p>同时每个页面包含:</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/layout/breadcrumb.html" target="_blank" rel="noopener noreferrer">路径导航</a></li>
<li><a href="https://theme-hope.vuejs.press/zh/guide/feature/page-info.html" target="_blank" rel="noopener noreferrer">标题和页面信息</a></li>
<li><a href="https://theme-hope.vuejs.press/zh/guide/layout/page.html#%E6%A0%87%E9%A2%98%E5%88%97%E8%A1%A8" target="_blank" rel="noopener noreferrer">TOC (文章标题列表)</a></li>
<li><a href="https://theme-hope.vuejs.press/guide/feature/meta.html" target="_blank" rel="noopener noreferrer">贡献者、更新时间等页面元信息</a></li>
<li><a href="https://theme-hope.vuejs.press/zh/guide/feature/comment.html" target="_blank" rel="noopener noreferrer">评论</a></li>
</ul>
<p>主题也带有以下元素:</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/interface/darkmode.html" target="_blank" rel="noopener noreferrer">夜间模式按钮</a></li>
<li><a href="https://theme-hope.vuejs.press/guide/interface/others.html#%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE" target="_blank" rel="noopener noreferrer">返回顶部按钮</a></li>
<li><a href="https://theme-hope.vuejs.press/guide/interface/others.html#%E6%89%93%E5%8D%B0%E6%8C%89%E9%92%AE" target="_blank" rel="noopener noreferrer">打印按钮</a></li>
</ul>
<p>你可以在主题选项和页面的 frontmatter 中自定义它们。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown 展示</title>
      <link>https://yangfeng1997.github.io/MyPages/demo/markdown.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/demo/markdown.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">Markdown 展示</source>
      <description>VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。 你需要创建并编写 Markdown，以便 VuePress 可以根据文件结构将它们转换为不同的页面。</description>
      <category>使用指南</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<p>VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。</p>
<p>你需要创建并编写 Markdown，以便 VuePress 可以根据文件结构将它们转换为不同的页面。</p>
<!-- more -->
<h2>Markdown 介绍</h2>
<p>如果你是一个新手，还不会编写 Markdown，请先阅读 <a href="https://theme-hope.vuejs.press/zh/cookbook/markdown/" target="_blank" rel="noopener noreferrer">Markdown 介绍</a> 和 <a href="https://theme-hope.vuejs.press/zh/cookbook/markdown/demo.html" target="_blank" rel="noopener noreferrer">Markdown 演示</a>。</p>
<h2>Markdown 配置</h2>
<p>VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。</p>
<div class="hint-container important">
<p class="hint-container-title">Frontmatter</p>
<p>Frontmatter 是 VuePress 中很重要的一个概念，请阅读 <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/page.html#front-matter" target="_blank" rel="noopener noreferrer">Frontmatter 介绍</a> 了解详情。</p>
</div>
<h2>Markdown 扩展</h2>
<p>VuePress 会使用 <a href="https://github.com/markdown-it/markdown-it" target="_blank" rel="noopener noreferrer">markdown-it</a> 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 <a href="https://github.com/markdown-it/markdown-it#syntax-extensions" target="_blank" rel="noopener noreferrer">语法扩展</a> 。</p>
<h3>VuePress 扩展</h3>
<p>为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。</p>
<p>关于这些扩展，请阅读 <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/markdown.html" target="_blank" rel="noopener noreferrer">VuePress 中的 Markdown 扩展</a>。</p>
<h3>主题扩展</h3>
<p>通过 VuePress 插件，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。</p>
<h4>选项卡</h4>

<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/content/tabs.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4>脚注</h4>
<p>此文字有脚注<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>.</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/content/footnote.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4>导入文件</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/content/include.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4>TeX 语法</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/grammar/math.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4>任务列表</h4>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 计划 1</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 计划 2</label></li>
</ul>
<p><a href="https://theme-hope.vuejs.press/zh/guide/markdown/grammar/tasklist.html" target="_blank" rel="noopener noreferrer">查看详情</a></p>
<h3>图片增强</h3>
<p>支持为图片设置颜色模式和大小。</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/grammar/image.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4>上下角标</h4>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/stylize/sup-sub.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4>组件</h4>
]]></content:encoded>
    </item>
    <item>
      <title>页面配置</title>
      <link>https://yangfeng1997.github.io/MyPages/demo/page.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/demo/page.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">页面配置</source>
      <description>more 注释之前的内容被视为文章摘要。</description>
      <category>使用指南</category>
      <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>more</code> 注释之前的内容被视为文章摘要。</p>
<!-- more -->
<h2>页面标题</h2>
<p>The first H1 title in Markdown will be regarded as page title.</p>
<p>Markdown 中的第一个 H1 标题会被视为页面标题。</p>
<p>你可以在 Markdown 的 Frontmatter 中设置页面标题。</p>
<div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://yangfeng1997.github.io/MyPages/assets/images/cover1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>樱桃</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/cherry.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/cherry.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">樱桃</source>
      <description>樱桃 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>樱桃</category>
      <pubDate>Sun, 09 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>火龙果</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/dragonfruit.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/dragonfruit.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">火龙果</source>
      <description>火龙果 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>火龙果</category>
      <category>水果</category>
      <pubDate>Mon, 10 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>草莓</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/strawberry.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/strawberry.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">草莓</source>
      <description>草莓 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>水果</category>
      <category>草莓</category>
      <pubDate>Tue, 11 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>番茄</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/tomato.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/tomato.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">番茄</source>
      <description>番茄 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>蔬菜</category>
      <pubDate>Wed, 12 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
      <enclosure url="https://yangfeng1997.github.io/MyPages/assets/images/cover2.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>使用VuePress构建个人知识网站</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/%E4%BD%BF%E7%94%A8VuePress%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%BD%91%E7%AB%99.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/%E4%BD%BF%E7%94%A8VuePress%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%BD%91%E7%AB%99.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">使用VuePress构建个人知识网站</source>
      <description>VuePress 是一个基于 Vue.js 的静态网站生成器，最初由 Vue.js 核心团队成员 Evan You (尤雨溪) 创建，主要用于编写技术文档，但现已发展为一个功能强大的静态站点生成工具。适合构建个人网站、博客或文档站点。下面详细记录构建过程！ 创建项目 第一步：安装 Node.js。 MacOS 使用 HomeBrew 安装。 Windo...</description>
      <category>建站</category>
      <category>VuePress</category>
      <pubDate>Sun, 20 Apr 2025 02:15:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>VuePress 是一个基于 Vue.js 的静态网站生成器，最初由 Vue.js 核心团队成员 Evan You (尤雨溪) 创建，主要用于编写技术文档，但现已发展为一个功能强大的静态站点生成工具。适合构建个人网站、博客或文档站点。下面详细记录构建过程！</p>
<h2>创建项目</h2>
<p><strong>第一步：安装 Node.js。</strong></p>
<p>MacOS 使用 HomeBrew 安装。</p>
<div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic"># 安装node</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">brew</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> install</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> node</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">node</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> -v</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">npm</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> -v</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic"># 升级npm</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">npm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> install</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> -g</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> npm@11.3.0</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Windows上，需要去官网上下载 node，点击 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener noreferrer">下载地址</a> 左侧的绿色按钮 (LTS)。</p>
<p><strong>第二步：创建VuePress项目。</strong></p>
<p>注意：为了避免一些因为路径引起的字符编码问题，需要使用纯英文路径，如：<code>D:\my-docs</code>。</p>
<p>在终端执行如下命令：</p>
<div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">npm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> init</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> vuepress-theme-hope@latest</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> my-docs</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div><p>在初次创建项目过程中，可以选择语言，通过键盘↑和↓方向键，以及回车键选择。</p>
<figure><figcaption>image-20250428214312366</figcaption></figure>
<p><strong>注意</strong>：为了后面部署到 github actions 上面，最好选择初始化仓库，并且部署 GitHub Pages 工作流。</p>
<p>在模板初始化成功后出现了一些 URL，你就可以在浏览器地址栏输入 <code>http://localhost:8080/</code> 访问开发服务器了。</p>
<p>项目创建的目录结构如下：</p>
<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.</span></span>
<span class="line"><span>├── .github                         (可选的) GitHub 配置文件存放路径</span></span>
<span class="line"><span>│    └── workflow → GitHub          工作流配置</span></span>
<span class="line"><span>│         └── docs-deploy.yml       自动部署文档的工作流</span></span>
<span class="line"><span>│</span></span>
<span class="line"><span>├── src →                           文档文件夹</span></span>
<span class="line"><span>│    │</span></span>
<span class="line"><span>│    ├── .vuepress                  (可选的) VuePress 配置文件夹</span></span>
<span class="line"><span>│    │    │</span></span>
<span class="line"><span>│    │    ├── dist                  (默认的) 构建输出目录</span></span>
<span class="line"><span>│    │    │</span></span>
<span class="line"><span>│    │    ├── public                (可选的) 静态资源目录</span></span>
<span class="line"><span>│    │    │</span></span>
<span class="line"><span>│    │    ├── styles                (可选的) 用于存放样式相关的文件</span></span>
<span class="line"><span>│    │    │</span></span>
<span class="line"><span>│    │    ├── config.{js,ts}        (可选的) 配置文件的入口文件</span></span>
<span class="line"><span>│    │    │</span></span>
<span class="line"><span>│    │    └── client.{js,ts}        (可选的) 客户端文件</span></span>
<span class="line"><span>│    │</span></span>
<span class="line"><span>│    ├── ...                        其他项目文档</span></span>
<span class="line"><span>│    │</span></span>
<span class="line"><span>│    └── README.md                  项目主页</span></span>
<span class="line"><span>│</span></span>
<span class="line"><span>└── package.json                    Nodejs 的配置文件</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：使用此种方式会自动安装主题：vuepress-theme-hope。<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2>项目命令</h2>
<p><code>vuepress dev &lt;dir&gt;</code> 会启动一个开发服务器，以便在本地开发你的 VuePress 站点。</p>
<p><code>vuepress build &lt;dir&gt;</code> 会将你的 VuePress 站点构建成静态文件，以便进行后续部署。</p>
<p>因为上面已经安装了 VuePress Theme Hope 模板，就可以在 package.json 中发现下列三个命令：</p>
<div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">  "scripts"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">    "docs:build"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"vuepress build src"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">,                                </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// npm run docs:build 构建项目并输出</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">    "docs:clean-dev"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"vuepress dev src --clean-cache --clean-temp"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">,   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// npm run docs:clean-dev 清除缓存并启动服务器</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">    "docs:dev"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"vuepress dev src"</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">                                     // npm run docs:dev 启动服务器</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>升级主题和 VuePress 版本，可以执行命令：</p>
<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>npx vp-update</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div><h2>配置文件</h2>
<p>VuePress 使用文档文件夹 <code>src </code>中的 <code>.vuepress</code> 文件夹存放配置。在 VuePress 中，有三种配置概念：</p>
<ul>
<li><strong>站点配置</strong>：站点配置中的配置项被 VuePress 直接读取，和主题无关且在所有主题均可生效。每一个站点都应该有它的 <code>lang</code>, <code>title</code> 和 <code>description</code> 等属性，因此 VuePress 内置支持了这些属性的配置。<a href="https://vuejs.press/zh/reference/config.html" target="_blank" rel="noopener noreferrer">参考文档</a></li>
<li><strong>主题配置</strong>：主题配置是你传递给 <code>hopeTheme</code> 函数的对象，它将由 VuePress Theme Hope 处理。<a href="https://theme-hope.vuejs.press/zh/config/theme/basic.html" target="_blank" rel="noopener noreferrer">参考文档</a></li>
<li><strong>页面配置</strong>：由在页面顶部基于 YAML 语法的 Frontmatter 提供。<a href="https://vuejs.press/zh/reference/frontmatter.html" target="_blank" rel="noopener noreferrer">参考文档</a></li>
</ul>
<p>具体选项参考的<a href="https://theme-hope.vuejs.press/zh/config/intro.html" target="_blank" rel="noopener noreferrer">配置介绍</a>，其中 <code>.vuepress/config.ts</code> (或 <code>.vuepress/config.js</code>) 是必要的配置文件（必须存在）。</p>
<p>模板中为了避免配置文件过长，会使用 JavaScript 原生提供的 ESM 特性：将主题配置、导航栏和侧边栏配置拆分到了单独的文件夹中。模板将主题函数抽离到了 <code>.vuepress/theme.ts</code> 中，并通过 <code>export default</code> 导出。</p>
<p>文件如下：</p>
<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>config.ts       # 项目配置</span></span>
<span class="line"><span>navbar.ts       # 导航栏</span></span>
<span class="line"><span>sidebar.ts      # 侧边栏</span></span>
<span class="line"><span>theme.ts        # 主题配置</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将主题函数抽离到了 <code>.vuepress/theme.ts</code>，并通过 <code>export default</code> 导出。</p>
<div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// theme.ts</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">defineUserConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> "vuepress"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">export</span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD"> default</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> defineUserConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">({</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">    // 此处放置配置</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">});</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在配置文件中直接引入抽离的 theme.ts：</p>
<div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// config.ts</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// 在这里引入主题</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">import</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75"> theme</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> "./theme.js"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">export</span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD"> default</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> defineUserConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">({</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">    // 这和 theme: hopeTheme({/* 主题配置 */}) 是等价的</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">    theme</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">});</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2>修改主题样式</h2>
<p>VuePress Theme Hope 主题使用 <code>.vuepress/styles</code> 文件夹存放样式配置（<a href="https://theme-hope.vuejs.press/zh/config/style.html" target="_blank" rel="noopener noreferrer">参考文档</a>）。可以在此文件夹中：</p>
<ul>
<li>创建 <code>index.scss</code> 来注入额外的 CSS 样式。</li>
<li>创建 <code>config.scss</code> 来进行样式配置。</li>
<li>创建 <code>palette.scss</code> 来配置颜色与布局。</li>
</ul>
<h2>文档创建</h2>
<p>VuePress 是以 Markdown 为中心的。项目中的每一个 Markdown 文件都是一个单独的页面。默认情况下，页面的路由路径是根据 Markdown 文件的相对路径决定的。如果上面是通过创建助手生成的，默认会得到以下文件结构：</p>
<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>└─ src</span></span>
<span class="line"><span>   ├─ demo</span></span>
<span class="line"><span>   │  ├─ ...</span></span>
<span class="line"><span>   │  └─ page.md</span></span>
<span class="line"><span>   │  └─ markdown.md</span></span>
<span class="line"><span>   │  └─ README.md</span></span>
<span class="line"><span>   ├─ ...</span></span>
<span class="line"><span>   └─ README.md</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Markdown 文件对应的路由路径为：</p>
<p>| 相对路径        | 路由路径        |<br>
|</p>
]]></content:encoded>
    </item>
    <item>
      <title>C++开源项目分享</title>
      <link>https://yangfeng1997.github.io/MyPages/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/C__%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%86%E4%BA%AB.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/C__%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%86%E4%BA%AB.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">C++开源项目分享</source>
      <description>高性能日志库：SpdLog 高性能通用 MPMC 无锁队列：ConcurrentQueue 高性能字符串格式化：fmt 高性能网络框架：Seastar 高性能内存分配器：mimalloc 高性能链接器：mold Google性能分析工具：gperftools 高性能正则表达式库：Hyperscan 分布式数据库：TiDB etcd的C++ 客户端库：e...</description>
      <category>开源代码</category>
      <pubDate>Fri, 25 Apr 2025 00:36:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2><a class="header-anchor" href="#高性能日志库-spdlog"><span>高性能日志库：</span></a><a href="https://github.com/gabime/spdlog/" target="_blank" rel="noopener noreferrer">SpdLog</a></h2>
<h2><a class="header-anchor" href="#高性能通用-mpmc-无锁队列-concurrentqueue"><span>高性能通用 MPMC 无锁队列：</span></a><a href="https://github.com/cameron314/concurrentqueue" target="_blank" rel="noopener noreferrer">ConcurrentQueue</a></h2>
<h2><a class="header-anchor" href="#高性能字符串格式化-fmt"><span>高性能字符串格式化：</span></a><a href="https://github.com/fmtlib/fmt" target="_blank" rel="noopener noreferrer">fmt</a></h2>
<h2><a class="header-anchor" href="#高性能网络框架-seastar"><span>高性能网络框架：</span></a><a href="https://github.com/scylladb/seastar" target="_blank" rel="noopener noreferrer">Seastar</a></h2>
<h2><a class="header-anchor" href="#高性能内存分配器-mimalloc"><span>高性能内存分配器：</span></a><a href="microsoft/mimalloc">mimalloc</a></h2>
<h2><a class="header-anchor" href="#高性能链接器-mold"><span>高性能链接器：</span></a><a href="https://github.com/rui314/mold" target="_blank" rel="noopener noreferrer">mold</a></h2>
<h2><a class="header-anchor" href="#google性能分析工具-gperftools"><span>Google性能分析工具：</span></a><a href="https://github.com/rui314/mold" target="_blank" rel="noopener noreferrer">gperftools</a></h2>
<h2><a class="header-anchor" href="#高性能正则表达式库-hyperscan"><span>高性能正则表达式库：</span></a><a href="https://github.com/intel/hyperscan" target="_blank" rel="noopener noreferrer">Hyperscan</a></h2>
<h2><a class="header-anchor" href="#分布式数据库-tidb"><span>分布式数据库：</span></a><a href="https://github.com/pingcap/tidb" target="_blank" rel="noopener noreferrer">TiDB</a></h2>
<h2><a class="header-anchor" href="#etcd的c-客户端库-etcd-cpp-apiv3"><span>etcd的C++ 客户端库：</span></a><a href="https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3" target="_blank" rel="noopener noreferrer">etcd-cpp-apiv3</a></h2>
<h2><a class="header-anchor" href="#分布式缓存中间件-dragonfly"><span>分布式缓存中间件：</span></a><a href="https://github.com/dragonflydb/dragonfly" target="_blank" rel="noopener noreferrer">dragonfly</a></h2>
]]></content:encoded>
    </item>
    <item>
      <title>苹果 1</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/apple/1.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/apple/1.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">苹果 1</source>
      <description>苹果 1 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>苹果</category>
      <pubDate>Sat, 01 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>苹果 2</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/apple/2.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/apple/2.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">苹果 2</source>
      <description>一个被星标了的苹果文章。</description>
      <category>苹果</category>
      <pubDate>Sun, 02 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>一个被星标了的苹果文章。</p>
<!-- more -->
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>苹果 3</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/apple/3.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/apple/3.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">苹果 3</source>
      <description>苹果 3 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>苹果</category>
      <category>水果</category>
      <pubDate>Mon, 03 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>苹果 4</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/apple/4.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/apple/4.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">苹果 4</source>
      <description>苹果 4 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>苹果</category>
      <category>水果</category>
      <pubDate>Tue, 04 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>香蕉 1</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/banana/1.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/banana/1.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">香蕉 1</source>
      <description>香蕉 1 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>香蕉</category>
      <category>水果</category>
      <pubDate>Wed, 05 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>香蕉 2</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/banana/2.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/banana/2.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">香蕉 2</source>
      <description>一个被数字 10 星标了的香蕉文章。</description>
      <category>香蕉</category>
      <category>水果</category>
      <pubDate>Thu, 06 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>一个被数字 <code>10</code> 星标了的香蕉文章。</p>
<!-- more -->
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>香蕉 3</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/banana/3.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/banana/3.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">香蕉 3</source>
      <description>香蕉 3 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>香蕉</category>
      <pubDate>Fri, 07 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>香蕉 4</title>
      <link>https://yangfeng1997.github.io/MyPages/posts/banana/4.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/posts/banana/4.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">香蕉 4</source>
      <description>香蕉 4 标题 2 这里是内容。 标题 3 这里是内容。</description>
      <category>香蕉</category>
      <pubDate>Sat, 08 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>标题 2</h2>
<p>这里是内容。</p>
<h3>标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP从入门到精通3</title>
      <link>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%20copy%202.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%20copy%202.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">HTTP从入门到精通3</source>
      <description>为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...</description>
      <category>HTTP</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>为什么需要分布式共识算法？</h2>
<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>
<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>
<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>
<h2>主要分布式共识算法</h2>
<ol>
<li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li>
<li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li>
<li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li>
</ol>
<h2>Paxos发展历史</h2>
<p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p>
<p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p>
<p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p>
<p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p>
<p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p>
<h2>Basic Paxos算法流程</h2>
<p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p>
<ul>
<li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li>
<li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li>
<li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ul>
<p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p>
<p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p>
<p>Paxos解决竞争分2个阶段：</p>
<ol>
<li>
<p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p>
<p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p>
<p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p>
</li>
<li>
<p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p>
</li>
</ol>
<ul>
<li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li>
<li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li>
</ul>
<p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p>
<p><strong>Multi Paxos共识算法</strong></p>
<p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p>
<p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p>
<ul>
<li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li>
<li>得到决策节点多数派的批准时，竞选主节点成功。</li>
</ul>
<p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p>
<p><strong>只有主从节点</strong></p>
<p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p>
<p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p>
<ul>
<li>如何选主</li>
<li>如何把数据复制到各个节点上</li>
<li>怎么保证过程是安全的</li>
</ul>
<p>3个问题解决了，就达成共识了。</p>
<p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p>
<p><strong>问题2：数据复制的过程？</strong></p>
<ul>
<li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li>
<li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li>
<li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li>
<li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li>
</ul>
<p><strong>问题3：过程是安全的？</strong></p>
<ul>
<li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li>
<li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li>
</ul>
<p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p>
<p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP从入门到精通2</title>
      <link>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%20copy.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%20copy.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">HTTP从入门到精通2</source>
      <description>为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...</description>
      <category>HTTP</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>为什么需要分布式共识算法？</h2>
<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>
<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>
<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>
<h2>主要分布式共识算法</h2>
<ol>
<li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li>
<li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li>
<li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li>
</ol>
<h2>Paxos发展历史</h2>
<p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p>
<p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p>
<p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p>
<p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p>
<p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p>
<h2>Basic Paxos算法流程</h2>
<p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p>
<ul>
<li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li>
<li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li>
<li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ul>
<p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p>
<p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p>
<p>Paxos解决竞争分2个阶段：</p>
<ol>
<li>
<p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p>
<p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p>
<p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p>
</li>
<li>
<p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p>
</li>
</ol>
<ul>
<li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li>
<li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li>
</ul>
<p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p>
<p><strong>Multi Paxos共识算法</strong></p>
<p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p>
<p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p>
<ul>
<li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li>
<li>得到决策节点多数派的批准时，竞选主节点成功。</li>
</ul>
<p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p>
<p><strong>只有主从节点</strong></p>
<p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p>
<p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p>
<ul>
<li>如何选主</li>
<li>如何把数据复制到各个节点上</li>
<li>怎么保证过程是安全的</li>
</ul>
<p>3个问题解决了，就达成共识了。</p>
<p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p>
<p><strong>问题2：数据复制的过程？</strong></p>
<ul>
<li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li>
<li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li>
<li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li>
<li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li>
</ul>
<p><strong>问题3：过程是安全的？</strong></p>
<ul>
<li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li>
<li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li>
</ul>
<p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p>
<p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP从入门到精通</title>
      <link>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">HTTP从入门到精通</source>
      <description>动态字符串类型 动态字符串类型 动态字符串类型 动态字符串类型 动态字符串类型 ####### 动态字符串类型 redis 使用了一种 SDS（simple dynamic string）类型的动态字符串，作为默认字符串的表示，并没有直接使用 C 语言中的字符串。 并且字符串的的键和值对在底层都是由 SDS 实现，因为键值对的键是一个字符串对象，字符串...</description>
      <category>HTTP</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>动态字符串类型</h2>
<h3>动态字符串类型</h3>
<h4>动态字符串类型</h4>
<h5>动态字符串类型</h5>
<h6>动态字符串类型</h6>
<p>####### 动态字符串类型</p>
<p>redis 使用了一种 SDS（simple dynamic string）类型的动态字符串，作为默认字符串的表示，并没有直接使用 C 语言中的字符串。</p>
<p>并且字符串的的<strong>键和值</strong>对在底层都是由 SDS 实现，因为键值对的键是一个字符串对象，字符串的值也是一个对象。</p>
<p>如果 list 中存储的也是字符串，那么列表中的每个字符串也都是 SDS 结构。</p>
<p>除了用来保存字符串值之外， SDS 还被用作缓冲区（buffer）： AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现。</p>
<p>SDS 结构：</p>
<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>struct sdshdr {</span></span>
<span class="line"><span>    int len;       // 记录 buf 数组中已使用字节的数量，等于 SDS 所保存字符串的长度</span></span>
<span class="line"><span>    int free;      // 记录 buf 数组中未使用字节的数量</span></span>
<span class="line"><span>    char buf[];    // 字节数组，用于保存字符串</span></span>
<span class="line"><span>};</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<p>![image-20250110184419641](Redis 设计与实现.assets/image-20250110184419641.png)</p>
<p>注意：保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 等操作都是由 SDS 函数自动完成，对使用者透明。这样做的好处是，可以重用一部分 C 语言字符串的函数，比如：有一个 SDS 的指针 s，可以直接使用 printf 函数，而不用专门编写 SDS 专门的打印函数。</p>
<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>printf("%s", s-&gt;buf);</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div><p>SDS 对比 C 字符串的优点：</p>
<ol>
<li>
<p>C 字符串不记录自身长度，获取长度的复杂度为 O(n)。而 SDS 直接取 len 的值，复杂度为 O(1)。</p>
</li>
<li>
<p>C 字符串容易造成缓冲区溢出，比如：</p>
<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>char *strcat(char *dest, const char *src);</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div><p>执行 strcat 时，需要用户已经为 dest 分配了足够的内存，如果没有的话将会发生内存溢出。</p>
<p>但是 SDS 完全杜绝了这种可能性，因为 SDS API 会检查空间是否满足修改所需的要求，如果不满足，API 会自动将空间扩容，比如 SDS 中的 sdscat 函数。</p>
</li>
<li>
<p>SDS 可以减少内存的分配次数。因为 C 字符串总是保证 N+1 个字符长的数组，每次增长或缩短字符串都要进行内存重新分配，这其中设计内存分配，可能会涉及系统调用，比较耗时，况且 redis 中一般字符串的操作比较频繁。</p>
<p>SDS 通过空间预分配和惰性空间释放，也就是 buf 数组的长度不一定就是字符串长度 +1，数组里可以有未使用的字节，有 free 属性记录。</p>
<p><strong>空间预分配</strong>：</p>
<p>SDS api 当对一个 SDS 进行修改及扩容时，不仅会分配必须要的空间，还会分配额外未使用的空间，再下次字符串增长时，如果未使用的空间足够就会直接使用这个空间，不执行内存分配。</p>
<p>当修改时 len 属性长度小于 1MB 时，程序会多分配 len 属性大小的未使用空间，这时候 len == free，总空间为 len + free + 1byte。</p>
<p>当修改时 len 长度大于等于 1MB 时，程序会多分配 1MB 的未使用空间，这时候总空间为 len + 1MB + 1byte。</p>
<p><strong>惰性释放空间</strong>：</p>
<p>用于字符串的缩短操作，SDS 的 api 并不立即使用内存重分配来回收缩短后多出来的字节，而是保留了空间，并使用 free 属性将这些字节记录下来，等待再进行增长操作时方便使用。同时 SDS 也提供了 api 让我们可以在有需要时，真正释放 SDS 中的未使用的空间，不用担心惰性空间释放造成的内存浪费。</p>
</li>
<li>
<p>SDS 是二进制安全的，C 字符串中不能包含空字符，否则会提前被判为字符串结束，所以 C 只能保存文本数据，不适合保存二进制。</p>
<p>所有的 SDS api 都以处理二进制的方式处理 SDS 存放在 buf 数组里的数据，不会对空字符进行过滤或者限制，SDS 是二进制安全的。SDS 的 buf 属性不是保存字符的，而是保存二进制数据的。</p>
</li>
</ol>
<h2>链表</h2>
<p>链表提供高效的节点重排能力，和顺序性节点的访问方式，可以高效的增删节点，Redis 也构建了自己的链表。</p>
<p>Redis 中，当一个列表键包含了数量比较多的元素时，或者列表中包含的元素都是比较长的字符串时，Redis 就是使用链表作为列表键的底层实现。还有发布与订阅、慢查询、监视器等功能也用到链表。</p>
<p>链表结构定义如下：</p>
<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct listNode {</span></span>
<span class="line"><span>    struct listNode *prev;   // 前置节点</span></span>
<span class="line"><span>    struct listNode *next;   // 后置节点</span></span>
<span class="line"><span>    void *value;             // 节点的值</span></span>
<span class="line"><span>} listNode;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>typedef struct list {</span></span>
<span class="line"><span>    listNode *head;          			// 表头节点</span></span>
<span class="line"><span>    listNode *tail;          			// 表尾节点</span></span>
<span class="line"><span>    unsigned long len;       			// 链表所包含的节点数量</span></span>
<span class="line"><span>    void *(*dup)(void *ptr); 			// 节点值复制函数</span></span>
<span class="line"><span>    void (*free)(void *ptr);            // 节点值释放函数</span></span>
<span class="line"><span>    int (*match)(void *ptr, void *key); // 节点值对比函数</span></span>
<span class="line"><span>} list;</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![image-20250111003218735](Redis 设计与实现.assets/image-20250111003218735.png)</p>
<p>![image-20250111003311059](Redis 设计与实现.assets/image-20250111003311059.png)</p>
<p>redis 链表有如下特征：</p>
<ol>
<li>双向，获取某个节点的前置和后置节点都是 O(1)。</li>
<li>无环，表头节点 pre 和表尾节点 next 都指向 NULL，对链表的访问以 NULL 为终点。</li>
<li>带表头指针和表尾指针，通过成员 head 指针和 tail 指针，获得头尾节点复杂度为 O(1)。</li>
<li>带暗恋长的长度计数器，通过成员 len 记录链表节点数量，复杂度 O(1)。</li>
<li>多态：节点使用 void*指针来保存节点值，可以通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数，链表可以保存各种不同的类型值。</li>
</ol>
<h2>字典</h2>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络1</title>
      <link>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1%20copy%202.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1%20copy%202.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">计算机网络1</source>
      <description>为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...</description>
      <category>计算机网络</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>为什么需要分布式共识算法？</h2>
<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>
<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>
<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>
<h2>主要分布式共识算法</h2>
<ol>
<li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li>
<li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li>
<li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li>
</ol>
<h2>Paxos发展历史</h2>
<p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p>
<p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p>
<p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p>
<p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p>
<p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p>
<h2>Basic Paxos算法流程</h2>
<p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p>
<ul>
<li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li>
<li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li>
<li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ul>
<p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p>
<p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p>
<p>Paxos解决竞争分2个阶段：</p>
<ol>
<li>
<p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p>
<p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p>
<p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p>
</li>
<li>
<p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p>
</li>
</ol>
<ul>
<li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li>
<li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li>
</ul>
<p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p>
<p><strong>Multi Paxos共识算法</strong></p>
<p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p>
<p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p>
<ul>
<li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li>
<li>得到决策节点多数派的批准时，竞选主节点成功。</li>
</ul>
<p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p>
<p><strong>只有主从节点</strong></p>
<p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p>
<p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p>
<ul>
<li>如何选主</li>
<li>如何把数据复制到各个节点上</li>
<li>怎么保证过程是安全的</li>
</ul>
<p>3个问题解决了，就达成共识了。</p>
<p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p>
<p><strong>问题2：数据复制的过程？</strong></p>
<ul>
<li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li>
<li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li>
<li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li>
<li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li>
</ul>
<p><strong>问题3：过程是安全的？</strong></p>
<ul>
<li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li>
<li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li>
</ul>
<p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p>
<p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络3</title>
      <link>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1%20copy.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1%20copy.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">计算机网络3</source>
      <description>为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...</description>
      <category>计算机网络</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>为什么需要分布式共识算法？</h2>
<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>
<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>
<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>
<h2>主要分布式共识算法</h2>
<ol>
<li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li>
<li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li>
<li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li>
</ol>
<h2>Paxos发展历史</h2>
<p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p>
<p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p>
<p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p>
<p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p>
<p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p>
<h2>Basic Paxos算法流程</h2>
<p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p>
<ul>
<li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li>
<li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li>
<li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ul>
<p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p>
<p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p>
<p>Paxos解决竞争分2个阶段：</p>
<ol>
<li>
<p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p>
<p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p>
<p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p>
</li>
<li>
<p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p>
</li>
</ol>
<ul>
<li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li>
<li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li>
</ul>
<p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p>
<p><strong>Multi Paxos共识算法</strong></p>
<p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p>
<p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p>
<ul>
<li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li>
<li>得到决策节点多数派的批准时，竞选主节点成功。</li>
</ul>
<p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p>
<p><strong>只有主从节点</strong></p>
<p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p>
<p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p>
<ul>
<li>如何选主</li>
<li>如何把数据复制到各个节点上</li>
<li>怎么保证过程是安全的</li>
</ul>
<p>3个问题解决了，就达成共识了。</p>
<p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p>
<p><strong>问题2：数据复制的过程？</strong></p>
<ul>
<li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li>
<li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li>
<li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li>
<li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li>
</ul>
<p><strong>问题3：过程是安全的？</strong></p>
<ul>
<li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li>
<li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li>
</ul>
<p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p>
<p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络2</title>
      <link>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">计算机网络2</source>
      <description>为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...</description>
      <category>计算机网络</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>为什么需要分布式共识算法？</h2>
<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>
<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>
<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>
<h2>主要分布式共识算法</h2>
<ol>
<li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li>
<li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li>
<li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li>
</ol>
<h2>Paxos发展历史</h2>
<p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p>
<p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p>
<p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p>
<p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p>
<p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p>
<h2>Basic Paxos算法流程</h2>
<p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p>
<ul>
<li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li>
<li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li>
<li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ul>
<p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p>
<p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p>
<p>Paxos解决竞争分2个阶段：</p>
<ol>
<li>
<p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p>
<p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p>
<p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p>
</li>
<li>
<p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p>
</li>
</ol>
<ul>
<li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li>
<li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li>
</ul>
<p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p>
<p><strong>Multi Paxos共识算法</strong></p>
<p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p>
<p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p>
<ul>
<li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li>
<li>得到决策节点多数派的批准时，竞选主节点成功。</li>
</ul>
<p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p>
<p><strong>只有主从节点</strong></p>
<p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p>
<p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p>
<ul>
<li>如何选主</li>
<li>如何把数据复制到各个节点上</li>
<li>怎么保证过程是安全的</li>
</ul>
<p>3个问题解决了，就达成共识了。</p>
<p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p>
<p><strong>问题2：数据复制的过程？</strong></p>
<ul>
<li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li>
<li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li>
<li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li>
<li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li>
</ul>
<p><strong>问题3：过程是安全的？</strong></p>
<ul>
<li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li>
<li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li>
</ul>
<p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p>
<p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP从入门到精通3</title>
      <link>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/HTTP2/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%20copy%202.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/HTTP2/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%20copy%202.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">HTTP从入门到精通3</source>
      <description>为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...</description>
      <category>HTTP</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>为什么需要分布式共识算法？</h2>
<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>
<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>
<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>
<h2>主要分布式共识算法</h2>
<ol>
<li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li>
<li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li>
<li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li>
</ol>
<h2>Paxos发展历史</h2>
<p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p>
<p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p>
<p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p>
<p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p>
<p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p>
<h2>Basic Paxos算法流程</h2>
<p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p>
<ul>
<li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li>
<li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li>
<li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ul>
<p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p>
<p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p>
<p>Paxos解决竞争分2个阶段：</p>
<ol>
<li>
<p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p>
<p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p>
<p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p>
</li>
<li>
<p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p>
</li>
</ol>
<ul>
<li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li>
<li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li>
</ul>
<p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p>
<p><strong>Multi Paxos共识算法</strong></p>
<p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p>
<p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p>
<ul>
<li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li>
<li>得到决策节点多数派的批准时，竞选主节点成功。</li>
</ul>
<p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p>
<p><strong>只有主从节点</strong></p>
<p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p>
<p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p>
<ul>
<li>如何选主</li>
<li>如何把数据复制到各个节点上</li>
<li>怎么保证过程是安全的</li>
</ul>
<p>3个问题解决了，就达成共识了。</p>
<p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p>
<p><strong>问题2：数据复制的过程？</strong></p>
<ul>
<li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li>
<li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li>
<li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li>
<li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li>
</ul>
<p><strong>问题3：过程是安全的？</strong></p>
<ul>
<li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li>
<li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li>
</ul>
<p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p>
<p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP从入门到精通2</title>
      <link>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/HTTP2/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%20copy.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/HTTP2/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%20copy.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">HTTP从入门到精通2</source>
      <description>为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...</description>
      <category>HTTP</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>为什么需要分布式共识算法？</h2>
<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>
<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>
<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>
<h2>主要分布式共识算法</h2>
<ol>
<li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li>
<li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li>
<li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li>
</ol>
<h2>Paxos发展历史</h2>
<p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p>
<p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p>
<p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p>
<p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p>
<p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p>
<h2>Basic Paxos算法流程</h2>
<p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p>
<ul>
<li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li>
<li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li>
<li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ul>
<p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p>
<p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p>
<p>Paxos解决竞争分2个阶段：</p>
<ol>
<li>
<p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p>
<p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p>
<p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p>
</li>
<li>
<p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p>
</li>
</ol>
<ul>
<li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li>
<li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li>
</ul>
<p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p>
<p><strong>Multi Paxos共识算法</strong></p>
<p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p>
<p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p>
<ul>
<li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li>
<li>得到决策节点多数派的批准时，竞选主节点成功。</li>
</ul>
<p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p>
<p><strong>只有主从节点</strong></p>
<p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p>
<p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p>
<ul>
<li>如何选主</li>
<li>如何把数据复制到各个节点上</li>
<li>怎么保证过程是安全的</li>
</ul>
<p>3个问题解决了，就达成共识了。</p>
<p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p>
<p><strong>问题2：数据复制的过程？</strong></p>
<ul>
<li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li>
<li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li>
<li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li>
<li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li>
</ul>
<p><strong>问题3：过程是安全的？</strong></p>
<ul>
<li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li>
<li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li>
</ul>
<p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p>
<p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP从入门到精通</title>
      <link>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/HTTP2/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html</link>
      <guid>https://yangfeng1997.github.io/MyPages/%E6%95%99%E7%A8%8B/HTTP/HTTP2/http%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html</guid>
      <source url="https://yangfeng1997.github.io/MyPages/rss.xml">HTTP从入门到精通</source>
      <description>为什么需要分布式共识算法？ 思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？ 在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，...</description>
      <category>HTTP</category>
      <pubDate>Fri, 25 Apr 2025 17:53:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2>为什么需要分布式共识算法？</h2>
<p>思考：现在你有一份随时变动的数据，需要确保它正确存储在网络的几台不同机器上，并且要保证数据是随时可用的，应该怎么做？</p>
<p>在分布式环境下，可以不必去追求系统内所有节点在任何情况下的数据状态都一致，采用“少数服从多数”的原则，认为数据的变化被正确存储在系统中。因此，我们需要一种算法，能够让分布式系统内部暂时容忍节点存在不同的状态，但最终大多数节点的状态能够一致。这种让系统能最终表现出整体一致性的过程，就是各个节点的<strong>协商共识</strong>。</p>
<p>分布式共识算法广泛用在：分布式数据库确保数据的一致性，分布式系统集群管理，状态机复制等。</p>
<h2>主要分布式共识算法</h2>
<ol>
<li>‌<strong>Paxos</strong>‌：被认为是分布式共识算法的根本，但其实现具有较高的工程复杂度。Paxos协议包括提议（Proposal）、准备（Prepare）和接受（Accept）等阶段，通过这些阶段确保所有诚实节点达成一致。</li>
<li>‌<strong>Raft</strong>‌：以容易理解著称，通过明确的角色划分（领导者、跟从者和候选人）来实现一致性。Raft将一致性分解为多个子问题，如Leader选举、日志同步等，简化了Paxos的实现。</li>
<li>‌<strong>ZAB</strong>‌：被应用在Zookeeper中，是一种广泛使用的算法，但未抽象成通用库。</li>
</ol>
<h2>Paxos发展历史</h2>
<p>Paxos算法最早是由Leslie Lamport（就是大名鼎鼎的LaTeX中的“La”）提出的一种基于消息传递的协商共识算法。</p>
<p>Lamport 在 1990 年首次发表了 Paxos 算法，选的论文题目就是“The Part-Time Parliament”。</p>
<p>但是由于论文使用了希腊城邦的比喻，使得论文更为晦涩难懂，审稿人要求Lamport进行修改，Lamport 非常不爽，然后干脆就撤稿不发了。</p>
<p>2001 年，Lamport 在“SIGACT News”杂志上发表了这篇论文，并放弃了“希腊城邦”的比喻。</p>
<p>2006 年，Google 的 Chubby、Megastore 和 Spanner 等分布式系统，都使用 Paxos 解决了分布式共识的问题，这才使得 Paxos 算法一夜间成为计算机科学分布式这条分支中，最炙手可热网红概念。</p>
<h2>Basic Paxos算法流程</h2>
<p>Basic Paxos算法将分布式系统中的节点分为<strong>提案者</strong>、<strong>决策者</strong>和<strong>记录者</strong>三类：</p>
<ul>
<li><strong>提案者（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就像提案，值设置成功后，不可变也不会丢失。</li>
<li><strong>决策者（Acceptor）</strong>：应答提案者，需要对提案进行投票，同时需要记住自己的投票历史。</li>
<li><strong>记录者（Learner）</strong>：超过半数决策者就某个提案达成了共识，那么记录者就需要接受这个提案，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ul>
<p><strong>Paxos算法怎么解决并发操作带来的竞争？</strong></p>
<p>分布式环境下，一个节点取得锁后，如果在释放锁之前发生崩溃，整个操作都会被无限期等待阻塞。</p>
<p>Paxos解决竞争分2个阶段：</p>
<ol>
<li>
<p><strong>准备Prepare</strong>：提案节点先广播一个Prepare请求，并附带一个全局数字 n 作为提案 ID，决策节点收到请求后，<strong>两个承诺，一个应答</strong>。</p>
<p><strong>承诺</strong>不在接收提案 ID 小于等于 n 的 Prepare 请求，也承诺不再接收小于 n 的 Accept 请求。</p>
<p><strong>应答</strong>已经批准过的提案中ID最大的那个。</p>
</li>
<li>
<p><strong>批准Accept</strong>：提案节点收到多数派的应答后，会有两种结果：</p>
</li>
</ol>
<ul>
<li>所有响应的决策者此前没有批准过这个值，即<strong>首次设值</strong>的情况，那就自己随意选定值与提案ID，广播给决策者。</li>
<li>响应决策节点中，已有至少一个节点的应答中包含有值了，<strong>非首次设值</strong>的情况，那么需要从应答中找出提案ID最大的那个值，再广播。协商共识结束。</li>
</ul>
<p>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下可能形成活锁。现在只做理论学习就行了。下面讲Multi Paxos算法。</p>
<p><strong>Multi Paxos共识算法</strong></p>
<p>概念：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p>
<p>相比较Basic Paxos算法，Multi Paxos增加了<code>选主</code>的过程：</p>
<ul>
<li>提案节点发现没有主提案节点时，使用准备、批准两轮网络交互，向其他节点广播自己竞选主节点请求</li>
<li>得到决策节点多数派的批准时，竞选主节点成功。</li>
</ul>
<p>选主之后，所有客户端请求都会由主节点来完成提案，不再需要准备过程，只需要执行批准交互即可：</p>
<p><strong>只有主从节点</strong></p>
<p>有了主节点后，角色可以简化，不再区分提案、决策、记录节点。只区分主、从节点。</p>
<p>于是，分布式系统中如何对某个值达成一致的问题可以分为3部分解决：</p>
<ul>
<li>如何选主</li>
<li>如何把数据复制到各个节点上</li>
<li>怎么保证过程是安全的</li>
</ul>
<p>3个问题解决了，就达成共识了。</p>
<p>这里针对问题2和问题3写些内容，用于应对可能的面试：</p>
<p><strong>问题2：数据复制的过程？</strong></p>
<ul>
<li>主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次<a href="https://zhida.zhihu.com/search?content_id=251314369&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BF%83%E8%B7%B3%E5%8C%85&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">心跳包</a>中广播给所有的从节点，并要求从节点回复“确认收到”的消息；</li>
<li>从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送“确认签收”的消息；</li>
<li>主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播“可以提交”的消息；</li>
<li>从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</li>
</ul>
<p><strong>问题3：过程是安全的？</strong></p>
<ul>
<li>协定性Safety：保证选主的结果一定有且只有唯一的主节点</li>
<li>终止性Liveness：保证选主过程一定是在某一时刻能够结束的</li>
</ul>
<p>从极客时间课程原文上没理解清楚这段的解释，先空着吧，后面理解了再修改这段</p>
<p>Paxos 算法不直接应用于工业界，理解原理理论就行。它的变体算法，比如我们今天学习的 Multi Paxos、Raft 算法，以及没有提到的 ZAB 等算法，都是分布式领域中的基石。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>